<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-behaviors/iron-button-state.html">
<link rel="import" href="../iron-behaviors/iron-control-state.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-behaviors/paper-ripple-behavior.html">

<!-- 
`polymer-live-editor-tab` behaves similarly to `paper-tab`. It should be used in conjunction with `polymer-live-editor`.

Example (notice one block inserts code inside a template and one directly edits the `htmlContent` property):
  <polymer-live-editor src="http://localhost:3000">
    <polymer-live-editor-tab tab-name="custom-element.html" id="customel">
      <div slot="heading">
        custom-element.html
      </div>
      <template slot="html-content"></template>
    </polymer-live-editor-tab>
    <polymer-live-editor-tab tab-name="index.html">
      <div slot="heading">
        index.html
      </div>
      <template slot="html-content">
        <script src="https://polygit.org/components/webcomponentsjs/webcomponents-loader.js"></script>
        <link rel="import" href="custom-element.html">
        <custom-element></custom-element>
      </template>
    </polymer-live-editor-tab>
  </polymer-live-editor>

  <script>
    var htmlContent = `<link rel="import"  href="https://polygit.org/components/polymer/polymer-element.html">
      <script>
        // Define the class for a new element called custom-element
        class CustomElement extends Polymer.Element {
          static get is() { return "custom-element"; }
          constructor() {
              super();
              this.textContent = "I'm a custom-element.";
            }
        }
        // Register the new element with the browser
        customElements.define(CustomElement.is, CustomElement);
      <`;
    htmlContent += '/script>';
    document.querySelector('#customel').htmlContent = htmlContent;
  </script>


The `polymer-live-editor` is used with as many `polymer-live-editor-tab`s as are needed for the demo. A `polymer-live-editor-tab` has one required property: `tabName`. Note that as long as the `polymer-live-editor-tab` is given a name, anything can be displaying in the tab itself. Tab content should be placed in a container with its `slot` attribute set to `heading`.

Each `polymer-live-editor-tab` has a property called `htmlContent`, which can be either set explicitly in Javascript (see the custom-element.html tab in the example) or will be computed based on the innerHTML of a template with slot `html-content` (the index.html tab in the example). 
 -->
 -->

<dom-module id="polymer-live-editor-tab">
  <template>
    <style>
      :host {
        @apply --layout-inline;
        @apply --layout-center;
        @apply --layout-center-justified;
        @apply --layout-flex-auto;

        position: relative;
        padding: 0 12px;
        overflow: hidden;
        cursor: pointer;
        vertical-align: middle;

        @apply --paper-font-common-base;
        @apply --paper-tab;
      }

      :host(:focus) {
        outline: none;
      }

      :host([link]) {
        padding: 0;
      }

      .tab-content {
        height: 100%;
        transform: translateZ(0);
          -webkit-transform: translateZ(0);
        transition: opacity 0.1s cubic-bezier(0.4, 0.0, 1, 1);
        @apply --layout-horizontal;
        @apply --layout-center-center;
        @apply --layout-flex-auto;
        @apply --paper-tab-content;
      }

      :host(:not(.iron-selected)) > .tab-content {
        opacity: 0.8;

        @apply --paper-tab-content-unselected;
      }

      :host(:focus) .tab-content {
        opacity: 1;
        font-weight: 700;
      }

      paper-ripple {
        color: var(--paper-tab-ink, var(--paper-yellow-a100));
      }

      .tab-content > ::content > a {
        @apply --layout-flex-auto;

        height: 100%;
      }
    </style>

    <div class="tab-content">
      <slot id="heading" name="heading"></slot>
    </div>
    <slot id="slot" name="html-content"></slot>
  </template>

  <script>
    Polymer({
      is: 'polymer-live-editor-tab',

      behaviors: [
        Polymer.IronControlState,
        Polymer.IronButtonState,
        Polymer.PaperRippleBehavior
      ],

      properties: {

        /**
         * If true, the tab will forward keyboard clicks (enter/space) to
         * the first anchor element found in its descendants
         */
        link: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        /**
         * Content of the `html-content` slot. Can be set programmatically or in HTML. 
         */
        htmlContent: {
          type: String,
          observer: '_htmlContentChanged'
        },
        /**
         * Name of tab, required for housekeeping.
         */
        tabName: {
          type: String
        }

      },

      observers: [
        '_onSlotChange(template.innerHTML)'
      ],

      hostAttributes: {
        role: 'tab'
      },

      listeners: {
        down: '_updateNoink',
        tap: '_onTap',
        'html-contents-changed': '_onHtmlContentsChanged'
      },

      attached: function() {
        this._updateNoink();
        this._htmlContentObserver = new MutationObserver(this._onSlotChange.bind(this));        
        this._templateObserver = Polymer.dom(this.$.slot).observeNodes(function(mutations) {
          let slot = Polymer.dom(this.$.slot); 
          let nodes  = slot.assignedNodes ? slot.assignedNodes({flatten: true}) : slot.getDistributedNodes();
          this.template = nodes.length ? nodes[0] : null;
          if (this.template && this.template.content) {
            this._htmlContentObserver.observe(this.template.content, {attributes: true, childList: true, subtree: true});
            this._htmlContentChanged();
          }
        }.bind(this));
      },

      detached: function() {
        this._htmlContentObserver.disconnect();
        Polymer.dom(this.$.slot).unobserveNodes(this._templateObserver);
      },

      _onSlotChange: function() { 
        if (!this.template) 
          return;
        this._fromSlot = true;
        
        this.htmlContent = this.template.innerHTML;
      },

      _onHtmlContentsChanged: function(event) {
        this._fromTabs = true;
        this.htmlContent = event.detail.htmlContent;
      },

      _htmlContentChanged: function() {   
        if (!this._fromSlot && this.template) {
          this.template.innerHTML = this.htmlContent;         
        } 
        if (!this._fromTabs)
          this.fire('html-content-changed', {content: this.htmlContent, tabName: this.tabName});
        this._fromTabs = false;
        this._fromSlot = false;       
      },

      get _parentNoink () {
        var parent = Polymer.dom(this).parentNode;
        return !!parent && !!parent.noink;
      },

      _updateNoink: function() {
        this.noink = !!this.noink || !!this._parentNoink;
      },

      _onTap: function(event) {
        if (this.link) {
          var anchor = this.queryEffectiveChildren('a');

          if (!anchor) {
            return;
          }

          // Don't get stuck in a loop delegating
          // the listener from the child anchor
          if (event.target === anchor) {
            return;
          }

          anchor.click();
        }
      }

    });
  </script>
</dom-module>

